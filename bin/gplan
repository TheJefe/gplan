#!/usr/bin/env ruby
#
# This script is used to find all of the planbox story numbers from the git log
# For lesson-player it is dependent on lesson-player being in the directory name for the repo

require 'pathname'
bin_path = Pathname.new(__FILE__).realpath
$:.unshift File.expand_path('../../lib', bin_path)
require 'planbox'
require 'github'

PB_STORY_REGEX=/\[(?:fixes)? *#*([0-9]*)\]/i
GH_PR_REGEX=/Merge pull request #(\d*)/i

@gh_release_array = []
@pb_release_array = []
@combined = []

def combine_results
  @pb_release_array.each do |pb_story|
    @gh_release_array.each do |gh_pr|
      if gh_pr['pb_id'] and gh_pr['pb_id'].to_i == pb_story["id"]
        gh_pr.delete('id') # doing this so we don't overide the pb id
        pb_story = pb_story.merge gh_pr
        @gh_release_array.delete gh_pr
        break
      end
    end
    @combined <<  pb_story
  end

  # add the remaining unmatched PRs
  @gh_release_array.each do |gh_pr|
    @combined <<  gh_pr
  end
end

# used to pull story numbers from pull request titles
def pull_pb_numbers_from_prs
  @gh_release_array.each do |gh_pr|
    pb_ids = gh_pr['title'].scan(PB_STORY_REGEX).flatten.uniq
      if !pb_ids.empty?
        gh_pr.merge!({"pb_id" => pb_ids.first.to_i}) # making an assumption that there is only 1 pb story number
      end
  end
end

def print
  end_of_pbs = false
  release_notes = "ID:STATUS:TITLE:PROJECT_NAME:PROJECT_ALIAS:PR:TITLE\n"
  @combined.each do |story|
    if !end_of_pbs and story['name'].nil?
      end_of_pbs = true
      release_notes += "\n---- Unmatched PRs ----\n\n"
      release_notes += "PR:TITLE\n"
    end
    line = ""
    line += "#{story['id']}:#{story['status']}:#{story['name']}:#{story['project_name']}:#{story['project_alias']}" unless end_of_pbs
    line += ":#{story['number']}:#{story['title']}" unless story['number'].nil?
    release_notes += line + "\n"
  end
  puts release_notes
end

def setup_repository
  if ARGV[0]  # allow you to pass in a SHA or remote/branch to target against. This can be useful when generating release notes after a deployment
    @target = ARGV[0]
  else
    conf_file =Dir.pwd+"/.gplan"
    if File.exists?(conf_file)
      File.open(conf_file, "r") do |f|
        #target should be repository/branch
        @target = f.each_line.first.chomp
      end
    end
  end
  # Set the default branch if one is not set
  @target = "production/master" unless @target
  @repo = @target.split("/").first
  begin
    `git fetch #{@repo}`
  rescue
    puts "unable to fetch #{@repo}, checking git log anyways..."
  end
end

# MAIN

setup_repository
list= `git log #{@target}..`

pb_story_ids = list.scan(PB_STORY_REGEX).flatten.uniq
gh_pr_ids = list.scan(GH_PR_REGEX).flatten.uniq
@gh_release_array = Github.get_release_notes_array gh_pr_ids
@pb_release_array = Planbox.get_release_notes_array pb_story_ids
pull_pb_numbers_from_prs
combine_results
print
